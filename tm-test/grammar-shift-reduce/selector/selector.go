// generated by Textmapper; DO NOT EDIT

package selector

import (
	"github.com/ddosakura/sakura-cat/tm-test/grammar"
)

type Selector func (nt grammar.NodeType) bool

var (
	Any = func(t grammar.NodeType) bool { return true }
	BindingIdentifier = func(t grammar.NodeType) bool { return t == grammar.BindingIdentifier }
	FunctionType = func(t grammar.NodeType) bool { return t == grammar.FunctionType }
	InterfaceItem = func(t grammar.NodeType) bool { return t == grammar.InterfaceItem }
	InterfaceType = func(t grammar.NodeType) bool { return t == grammar.InterfaceType }
	LiteralType = func(t grammar.NodeType) bool { return t == grammar.LiteralType }
	ParameterList = func(t grammar.NodeType) bool { return t == grammar.ParameterList }
	PredefinedType = func(t grammar.NodeType) bool { return t == grammar.PredefinedType }
	RetList = func(t grammar.NodeType) bool { return t == grammar.RetList }
	StructType = func(t grammar.NodeType) bool { return t == grammar.StructType }
	MultiLineComment = func(t grammar.NodeType) bool { return t == grammar.MultiLineComment }
	SingleLineComment = func(t grammar.NodeType) bool { return t == grammar.SingleLineComment }
	InvalidToken = func(t grammar.NodeType) bool { return t == grammar.InvalidToken }
	SkrType = OneOf(grammar.SkrType...)
)

func OneOf(types ...grammar.NodeType) Selector {
	if len(types) == 0 {
		return func(grammar.NodeType) bool { return false }
	}
	const bits = 32
	max := 1
	for _, t := range types {
		if int(t) > max {
			max = int(t)
		}
	}
	size := (max + bits) / bits
	bitarr := make([]uint32, size)
	for _, t := range types {
		bitarr[uint(t)/bits] |= 1 << (uint(t) % bits)
	}
	return func(t grammar.NodeType) bool {
		i := uint(t)/bits
		return int(i) < len(bitarr) && bitarr[i]&(1<<(uint(t)%bits)) != 0
	}
}
