// generated by Textmapper; DO NOT EDIT

package ast

import (
	"github.com/ddosakura/sakura-cat/tm-test/grammar/selector"
)

// Interfaces.

type SkrNode interface {
	SkrNode() *Node
}

type Token struct {
	*Node
}

type NilNode struct {}

var nilInstance = &NilNode{}

// All types implement SkrNode.
func (n BindingIdentifier) SkrNode() *Node { return n.Node }
func (n FunctionType) SkrNode() *Node { return n.Node }
func (n InterfaceItem) SkrNode() *Node { return n.Node }
func (n InterfaceType) SkrNode() *Node { return n.Node }
func (n LiteralType) SkrNode() *Node { return n.Node }
func (n ParameterList) SkrNode() *Node { return n.Node }
func (n PredefinedType) SkrNode() *Node { return n.Node }
func (n RetList) SkrNode() *Node { return n.Node }
func (n StructType) SkrNode() *Node { return n.Node }
func (n Token) SkrNode() *Node { return n.Node }
func (NilNode) SkrNode() *Node { return nil }

type SkrType interface {
	SkrNode
	skrTypeNode()
}

// skrTypeNode() ensures that only the following types can be
// assigned to SkrType.
//
func (FunctionType) skrTypeNode() {}
func (InterfaceType) skrTypeNode() {}
func (LiteralType) skrTypeNode() {}
func (PredefinedType) skrTypeNode() {}
func (StructType) skrTypeNode() {}
func (NilNode) skrTypeNode() {}

// Types.

type BindingIdentifier struct {
	*Node
}

type FunctionType struct {
	*Node
}

func (n FunctionType) ParameterList() []ParameterList {
	nodes := n.Children(selector.ParameterList)
	var ret = make([]ParameterList, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ParameterList{node})
	}
	return ret
}

func (n FunctionType) RetList() (RetList, bool) {
	field := RetList{n.Child(selector.RetList)}
	return field, field.IsValid()}

type InterfaceItem struct {
	*Node
}

func (n InterfaceItem) BindingIdentifier() BindingIdentifier {
	return BindingIdentifier{n.Child(selector.BindingIdentifier)}
}

func (n InterfaceItem) ParameterList() []ParameterList {
	nodes := n.Children(selector.ParameterList)
	var ret = make([]ParameterList, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ParameterList{node})
	}
	return ret
}

func (n InterfaceItem) RetList() (RetList, bool) {
	field := RetList{n.Child(selector.RetList)}
	return field, field.IsValid()}

type InterfaceType struct {
	*Node
}

func (n InterfaceType) InterfaceItem() []InterfaceItem {
	nodes := n.Children(selector.InterfaceItem)
	var ret = make([]InterfaceItem, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, InterfaceItem{node})
	}
	return ret
}

type LiteralType struct {
	*Node
}

func (n LiteralType) BindingIdentifier() BindingIdentifier {
	return BindingIdentifier{n.Child(selector.BindingIdentifier)}
}

type ParameterList struct {
	*Node
}

func (n ParameterList) BindingIdentifier() []BindingIdentifier {
	nodes := n.Children(selector.BindingIdentifier)
	var ret = make([]BindingIdentifier, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, BindingIdentifier{node})
	}
	return ret
}

func (n ParameterList) SkrType() SkrType {
	return ToSkrNode(n.Child(selector.SkrType)).(SkrType)
}

type PredefinedType struct {
	*Node
}

type RetList struct {
	*Node
}

func (n RetList) SkrType() []SkrType {
	nodes := n.Children(selector.SkrType)
	var ret = make([]SkrType, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToSkrNode(node).(SkrType))
	}
	return ret
}

type StructType struct {
	*Node
}

func (n StructType) ParameterList() []ParameterList {
	nodes := n.Children(selector.ParameterList)
	var ret = make([]ParameterList, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ParameterList{node})
	}
	return ret
}


